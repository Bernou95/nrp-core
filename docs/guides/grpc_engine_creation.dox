/*! \page grpc_engine_creation Creating an Engine based on the gRPC Engine

We provide a generic engine that supports protobuf over gRPC as the communication protocol between engine client and server.
A minimal working gRPC engine can be created using a script that comes with NRP Core.
The script is going to create the following components:

- Client class, allowing NRP Core to communicate with the server process.
- Server class, responsible for direct interactions with the simulator.
- Server executable, which allows to start the server as a separate process
- DataPack controller class, responsible for passing data to and from the simulation.
The class will be used by the engine server.
- CMakeLists.txt that allows to compile the new code.
- Minimal experiment, that allows to verify if the newly created code works as expected.

In most cases the only entities that will need further modifications are the server class and the datapack controller class,
as they are the two classes that are going to directly interact with your simulator.

<em>Please note that in order to use this engine your simulator has to provide a C/C++ API.</em>


\section grpc_engine_creation_script Creating a new gRPC engine


\subsection grpc_engine_creation_script_name Engine name

In order to generate a new engine, you will need to choose a name.
This name will be used to generate all other names in the engine - classes, directories, modules etc.
Ideally it should be a single word, for example the name of your simulator, and start with an uppercase letter.


\subsection grpc_engine_creation_script_code Generating and compiling code

We are going to create a gRPC engine called TestGrpcEngine

To generate the code of the new engine:

\code{.sh}
cd tools
./create_new_engine.py --name Test --type grpc
\endcode

This command should create a new directory called test_grpc_engine.
Move it to the top-level directory:

\code{.sh}
mv test_grpc_engine ../test_grpc_engine
\endcode

To compile the new engine, add the following line at the end of the top-level CMakeLists.txt:

\code
add_subdirectory("test_grpc_engine")
\endcode

Compile the code:

\code{.sh}
cd build
make -j8 install
\endcode

In order to verify that the newly created engine works, you can run the example experiment provided with the engine:

\code{.sh}
cd ../test_grpc_engine/example_experiment
NRPCoreSim -c simulation_config.json -p "NRPTestGrpcEngine.so"
\endcode


\section grpc_engine_creation_client Client side

\subsection grpc_engine_creation_client_configuration Configuration

A generic configuration schema for gRPC engines is used - \ref engine_grpc_config_section "gRPC engine configuration".
You can create your own configuration using provided schema as a base.


\subsection grpc_engine_creation_client_class Client class

The client class doesn't need any modifications in order to work.


\section grpc_engine_creation_server Server side

\subsection grpc_engine_creation_server_class Server class

In order to control the simulation, the following methods of the server class must be implemented:
- EngineGrpcServer::initialize() - should initialize the simulation.
The function will receive full simulation configuration as JSON object.
- EngineGrpcServer::runLoopStep() - this function is supposed to advance the simulation by requested time step.
- EngineGrpcServer::shutdown() - should gracefully shut down the simulation.
- EngineGrpcServer::reset() - optional. Should reset the simulation to its initial state.


\subsection grpc_engine_creation_server_controllers DataPack controllers

DataPack controllers (DataPackController) are helper classes which facilitate data exchange between the simulator and the server part of the engine.
They can be thought of as adaptors between data arriving from the engine client in form of protobuf messages, and arbitrary
data from the simulation.

Our minimal gRPC engine comes with a single datapack controller class, but more may be added if a need arises.

The following methods of the controller should be implemented:

- DataPackController::getDataPackInformationCallback() should return a protobuf object with the most recent simulation results.
This data will be then passed from the engine server to the client, and from there to the transceiver functions.
The function will be called before runLoopStep.

- DataPackController::handleDataPackDataCallback() should inject received protobuf data into the simulator.
The function will be called after runLoopStep.

*/
