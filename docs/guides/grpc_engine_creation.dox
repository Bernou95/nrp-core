/*! \page grpc_engine_creation Creating an Engine based on the GRPC Engine

We provide a generic engine that supports gRPC as the communication protocol between engine client and server.
The following elements are engine/simulator specific and must still be implemented:
- Device types - used as containers for simulation data, will allow to access the data in transceiver functions
- protobuf message definitions - their structure should match that of the device types
- functions to (de-)serialize devices to/from protobuf messages
- simulator-specific functionality, like initialization, shutdown and loop step, on both client and server side
- data exchange between the simulator and Simulation Loop on the server side

\section grpc_engine_creation_devices Devices

This section uses device example developed in \ref tutorial_device_creation "Creating a new device" tutorial.

Devices as data containers are used by both client and server. The client retrieves device objects from transceiver functions.
They are serialized into protobuf messages and sent to the server. The server deserializes them back into device objects, which
may be consumed by the simulator.

The server produces new data as a result of running runLoopStep command. The data is then packed into device objects.
The devices are serialized into protobuf messages, when the client requests the data. On the client side, they are
deserialized back into devices, which may be passed to transceiver functions.

To be able to use the gRPC engine, each Device type must have a serialize and deserialize methods.

Declarations in the header file:

\dontinclude example_engine/grpc_devices/my_device_grpc.h
\skip template<>
\until MyDevice DeviceSerializerMethods

Definitions in the source file:

\dontinclude example_engine/grpc_devices/my_device_grpc.cpp
\skip template<>
\until }
\until }
\until }
\until }

The source files may be put in the `devices` folder of your \ref tutorial_engine_creation_directories "engine directory".

\section grpc_engine_creation_proto Protobuf messages

This section uses device example developed in \ref tutorial_device_creation "Creating a new device" tutorial.

Add a new message to `nrp_engine_protocols/nrp_grpc_engine_protocol/grpc_server/engine_grpc.proto` file.
Please refer to <a href="https://developers.google.com/protocol-buffers/docs/proto3">proto3 language guide</a> to check available protobuf types.

We propose that structure of your proto messages correspond to
structure of device classes that you are going to use in your simulation. This will make device (de-)serialization
much easier.

\dontinclude example_engine/proto/messages.proto
\until }

Add the newly created message to `DeviceMessage` proto message (in the same file), in the `oneof data` section. The aggregate `DeviceMessage`
structure is used internally by the engine, and it must be aware of all new message types, that are serializable into devices.

\until }
\until }

\section grpc_engine_creation_client Client side

\subsection Configuration

A generic configuration schema for gRPC engines is available - \ref engine_grpc_config_section "gRPC engine configuration".
You can create your own configuration using this provided schema as a base.

\subsection grpc_engine_creation_client_class Client class

We provide a base class for a gRPC-based client, called EngineGrpcClient.
It implements some of the EngineClientInterface methods, like runLoopStep and data exchange methods.
It also spawns a gRPC stub, based on the proto file definition mentioned earlier.

The concrete client class should derive from EngineGrpcClient. Template arguments to the base class are:
- derived client class
- URI of the configuration schema
- All device classes used by the engine

\dontinclude example_engine/grpc_engine/grpc_client.h
\until : public

The client class should also override the following methods:
- EngineGrpcClient::initialize()
- EngineGrpcClient::shutdown()
- EngineGrpcClient::engineProcStartParams()
- EngineGrpcClient::engineProcEnvParams()

\until };

An engine launcher should also be instantiated here:

\until CREATE_NRP_ENGINE_LAUNCHER

\section grpc_engine_creation_server Server side

\subsection grpc_engine_creation_server_class Server class

We provide a base class for engine servers with gRPC support, called EngineGrpcServer. The class implements bulk of the needed functionality:
- spawns a gRPC server with parameters specified in engine configuration.
- provides implementation of necessary gRPC services, needed to handle requests from the client. Simulator-specific code still needs
to be provided

The concrete server class should override the following methods of the base class:
- EngineGrpcServer::runLoopStep()
- EngineGrpcServer::initialize()
- EngineGrpcServer::shutdown()

\subsection grpc_engine_creation_server_controllers Device controllers

Device controllers (EngineDeviceController) are helper classes which facilitate data exchange between the simulator and the server part of the engine.
They can be thought of as adaptors between data arriving from the engine, in the form of devices, and arbitrary
data from the simulation. Every device type should have its own device controller, which understands how
to inject new data to the simulation and how to retrieve results from it.

Device controllers should be based on EngineGrpcDeviceController class. Every device controller
should implement the following methods:

- EngineDeviceController::getDeviceInformationCallback() should return a device object with the most recent simulation results.
The function will be called before runLoopStep.

- EngineDeviceController::handleDeviceDataCallback() should inject data received from the Simulation Loop into the simulator.
The function will be called after runLoopStep.

*/
