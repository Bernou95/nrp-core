/*! \page json_engine_creation Creating an Engine based on the JSON Engine

We provide a generic engine that supports JSON/REST as the communication protocol between engine client and server.
The following elements are engine/simulator specific and must still be implemented:
- Device types - used as containers for simulation data, will allow to access the data in transceiver functions
- simulator-specific functionality, like initialization, shutdown and loop step, on both client and server side
- data exchange between the simulator and Simulation Loop on the server side

\section json_engine_creation_devices Devices

Devices as data containers are used by both client and server. The client retrieves device objects from transceiver functions.
They are serialized into JSON objects and sent to the server through REST. The server deserializes them back into device objects, which
may be consumed by the simulator.

The server produces new data as a result of running runLoopStep command. The data is then packed into device objects.
The devices are serialized into REST objects, when the client requests the data. On the client side, they are
deserialized back into devices, which may be passed to transceiver functions.

Serialization and deserialization are performed automatically, thanks to PropertyTemplates used
in Device type definitions.

If you are interested in adding new device types, please take a look at our \ref tutorial_device_creation "tutorial".


\section json_engine_creation_client Client side

\subsection json_engine_creation_client_configuration Configuration

A generic configuration schema for JSON engines is available - \ref engine_json_config_section "JSON engine configuration".
You can create your own configuration using provided schema as a base.

\subsection json_engine_creation_client_class Client class

We provide a base class for JSON-based client, called EngineJSONNRPClient.
It implements some of the EngineClientInterface methods, like runLoopStep and data exchange methods.
It also spawns a REST server, with configuration specified by the user.

The concrete client class should derive from EngineJSONNRPClient. Template arguments to the base class are:
- derived client class
- URI of the configuration schema
- All device classes used by the engine

\dontinclude example_engine/json_engine/json_client.h
\until : public

The client class should also override the following methods:
- EngineJSONNRPClient::initialize()
- EngineJSONNRPClient::shutdown()
- EngineJSONNRPClient::engineProcStartParams()
- EngineJSONNRPClient::engineProcEnvParams()

\until };

An engine launcher should also be instantiated here:

\until CREATE_NRP_ENGINE_LAUNCHER


\section json_engine_creation_server Server side

\subsection json_engine_creation_server_class Server class

We provide a base class for engine servers with JSON through REST support, called EngineJSONServer. The class implements bulk of the needed functionality:
- spawns a REST server with parameters specified in engine configuration.
- provides implementation of necessary REST handlers, needed to process requests from the client. Simulator-specific code still needs
to be provided

The concrete server class should override the following methods of the base class:
- EngineJSONServer::runLoopStep()
- EngineJSONServer::initialize()
- EngineJSONServer::shutdown()

\subsection json_engine_creation_server_controllers Device controllers

%Device controllers (EngineDeviceController) are helper classes which facilitate data exchange between the simulator and the server part of the engine.
They can be thought of as adaptors between data arriving from the engine, if form of devices, and arbitrary
data from the simulation. Every device type should have it's own device controller, which understands how
to inject new data to the simulation and how to retrieve results from it.

%Device controllers should be based on EngineJSONDeviceController class. Every device controller
should implement the following methods:

- EngineDeviceController::getDeviceInformationCallback() should return a device object with the most recent simulation results.
The function will be called before runLoopStep.

- EngineDeviceController::handleDeviceDataCallback() should inject received data into the simulator.
The function will be called after runLoopStep.

*/

