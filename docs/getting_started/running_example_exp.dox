/*! \page running_example_exp Running the example experiments

In this section, we show how to run some of the example experiments. Different experiments utilize different
features of the NRP, the use of which will be highlighted.

Experiments are run using the provided application \ref nrp_simulation. It takes as argument the \ref simulation_configuration "simulation configuration file" used to configure the experiment. Optionally a list of \ref plugin_system "engine plugins" to be loaded at run time can be specified. This can be done using the "-p" parameter. If "-p" is not used, all engine plugins built with nrp-core will be loaded.

\section getting_started_experiment_husky Husky braitenberg

This experiment replicates the omnipresent <i>Husky Braitenberg</i> experiment often used in previous versions of the NRP to exemplify its functionality. More details about the experiment can be found <a href="https://neurorobotics.net/Documentation/nrp/user_manual/user_interface/introduction.html#template-experiments">here</a>. It displays a virtual robot connected to a brain reacting to color stimuli.

The experiment engages two simulators, <a href="http://gazebosim.org/">Gazebo</a> as robot simulator, and <a href="https://www.nest-simulator.org/">NEST</a> as neural network simulator.

Both Gazebo and NEST are wrapped into so-called \ref engines "engines", which allow the NRP to manage simulation execution and synchronization. Data exchange between the simulators is done with the help of \ref transceiver_function "transceiver functions" and \ref datapacks "datapacks". In short, the transceiver functions allow to translate output of one simulator into input of another one, while the datapacks serve as generic containers for the data.

The Gazebo engine starts Gazebo server (gzserver), so you should be able to peek into the simulation by connecting with Gazebo client (`gzclient`) from a separate terminal.

To run the example, if you haven't done it yet, you have to install first some additional Gazebo models. Instructions on how to do it can be found in this page: \ref tutorial_helpful_info_husky. Once this is done, switch to the proper directory and run the NRP simulation executable:

\code{.sh}
cd examples/husky_braitenberg
NRPCoreSim -c simulation_config.json -p "NRPGazeboGrpcEngine.so,NRPNestJSONEngine.so"
\endcode

<em>Please note that the NRPCoreSim must be executed from the example directory!</em>

Here is a short description of all files that are located in the example directory:
- braitenberg.py - contains the setup of the neuronal network running the experiment. Used by NEST.
- cam_tf.py - transceiver function which converts images acquired by the robot into input usable by NEST.
- husky_world.sdf - simulation world file in <a href="http://sdformat.org/">Simulation Description Format</a>. Used by Gazebo.
- mot_tf.py - transceiver function that converts output from NEST into movement commands.
- simulation_config.json - simulation configuration file. An explanation of the simulation configuration can be found \ref simulation_configuration "here".


\section getting_started_experiment_husky_pf Husky braitenberg with preprocessing function

This experiment is a modification of the previous one and shows how to use one of the tools provided by the NRP - the \ref preprocessing_function "preprocessing function".
Preprocessing functions are called before transceiver functions.
The use of preprocessing functions is intended to increase computational efficiency when several transceiver functions would otherwise carry out multiple times the same operations on the same data.

The preprocessing function used in the example converts RGB images received from Gazebo into grayscale images. The processed images are passed to one of the transceiver functions (`cam_tf.py`) and can be displayed after changing `False` to `True` in the following piece of code:

\dontinclude husky_braitenberg_with_preprocessing/cam_tf.py
\skip # Set to True
\until time.sleep

The code of the preprocessing function is located in `grayscale.py` file.

To run the example, switch to the proper directory and run the NRP simulation executable:

\code{.sh}
cd examples/husky_braitenberg_with_preprocessing
NRPCoreSim -c simulation_config.json
\endcode


\section getting_started_experiment_husky_nest_server Husky braitenberg with NEST server

This example is again a modification of the husky braitenberg experiment, in this case using a client-only engine that connects to an instance of <a href="https://pypi.org/project/nest-server/">NEST server</a>. To load the engine, its library must be specified on the command line when launching the NRP executable:

\code{.sh}
cd examples/husky_braitenberg_nest_server
NRPCoreSim -c simulation_config.json
\endcode

This will also start nest-server in a separate process.

\section getting_started_experiment_tf_exchange DataPack Exchange using the Python JSON Engine

This simple example shows two instances of \ref python_json_engine exchanging data as datapacks. Data exchange between the simulators is done with the help of \ref transceiver_function "Transceiver Functions" (TFs) and \ref datapacks "datapacks".

The PythonJSONEngine implements a Python class, <i>EngineScript</i>, the methods <i>initialize</i>, <i>runLoop</i> and <i>shutdown</i> of which can be overriden to execute any arbitrary piece of Python code synchronously in a NRP experiment. This opens the possibility of easily integrating any simulator with a Python API in an experiment (e.g. OpenSim, OpenAI Gym, etc.). Under the hood, <i>EngineScript</i> manages DataPack I/O operations with the Simulation Loop.

In the example, which can be found in <i>examples/tf_exchange</i> folder, an engine defined in <i>engine_1.py</i> file registers a datapack of type \ref datapacks_json "JsonDataPack" with id "datapack1". The datapack stores a dictionary with the current simulation time in the engine and the number of simulation steps the engine has already advanced. Then a TF defined in <i>tf_1.py</i> gets this datapack and relays it to a second engine defined in <i>engine_2.py</i>, which simply prints out its data.

\ref python_json_engine only supports <i>JsonDataPack</i> datapack type, which stores a wraps a JSON object in an attribute <i>data</i>. Therefore it allows to send any kind of data between Engines and TFs with the only constraint of it being JSON serializable. <i>JsonDataPack</i> is defined in the <i>nrp_core.nrp_json</i> module from which it can be imported. Eg:

\code{.py}
from nrp_core.data.nrp_json import JsonDataPack
\endcode

To launch the example, just execute:

\code{.sh}
cd examples/tf_exchange
NRPCoreSim -c simulation_config.json
\endcode

In this case, no additional plugin needs to be specified.


\section getting_started_experiment_OpenSIm_Arm26 OpenSim with dummy controller for Arm26 model

This experiment implements a dummy controller for a simple OpenSim model of the human arm (arm26, see <a href="https://simtk-confluence.stanford.edu:8443/display/OpenSim/Musculoskeletal+Models">https://simtk-confluence.stanford.edu:8443/display/OpenSim/Musculoskeletal+Models</a>) in an OpenSim scene.

This experiment uses two kinds of so-called engines (\ref python_json_engine "NRPPythonJSONEngine" and \ref opensim_engine "NRPOpenSimEngine"), and illustrates how the NRP manages execution of the OpenSim simulation and synchronization with other engines. The communication between OpenSim and the python controller is done with the help of \ref transceiver_function "transceiver functions" and \ref datapacks "engine datapacks". In short, the transceiver functions allow translating the I/O data between different platforms, while the datapacks serve as generic containers for the data.

To run the example, switch to the experiment directory and run the NRP simulation executable:

\code{.py}
cd examples/opensim_control
NRPCoreSim -c simulation_config.json
\endcode

This will start the OpenSim simulation with proper visualization.

Here is a short description of all files that are located in the example directory:
- Folder “arm26” – include the simulation file of the OpenSim scene
- server.py - contains the setup of the OpenSim simulation, including initialize, runLoop, reset, and shutdown
- client.py - contains the setup of the python controller
- send_cmd.py - transceiver function that converts output from the Python controller into simulation commands
- rec_joints.py - transceiver function which converts feedback muscle data from OpenSim
- simulation_config.json - simulation configuration file. An explanation of the simulation configuration can be found \ref simulation_configuration "here"


*/
