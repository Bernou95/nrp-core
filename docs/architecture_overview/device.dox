/*! \page devices Devices

\ref transceiver_function "Transceiver functions" use devices to relay data between engines. Devices are simple data structures, which can contain scalar types, strings or arrays and vectors of these elements. Each engine type is designed to accept only certain types of devices. To discover which device types can be processed by an engine, check out the engine's documentation \ref nrp_engines "here". In each engine type page, the Python modules which make devices accessible from Python are  also listed. These modules can be a useful source of information for the user looking into the structure of devices.

Along with the actual data, every device contains one DeviceIdentifier. It uniquely identifies a device both on the engine and simulation loop sides and specifies to which engine the device should be sent to or requested from. It consists of three string: the device's name, its type, and the corresponding engine's name.

The Device base class is DeviceInterface, which contains the DeviceIdentifier necessary for identifying the corresponding engine. Additionally, devices must be de-/serializable in a manner that makes communication with an Engine possible. The mechanism for device de-/serialization is based on the use of PropertyTemplates. De-/serialization of devices is discussed \ref device_serialization "below".

To implement new device types, developers can use the Device template as a base. It derives a DeviceInterface as well as a PropertyTemplate containing all requested properties. An example device class is listed below. It implements a device with two properties, `string` and `number`, of types string and int.

\code{.cpp}
#include "nrp_general_library/device_interface/device.h"

class ExampleDevice
        : public Device<ExampleDevice, "ExampleDevice", PropNames<"number", "string">, int, std::string>
{
	public:
		// Constructor. property_template_t refers to the PropertyTemplate<> base class.
		// Note the default property values. If no property_template_t is specified, they will be used
		ExampleDevice(DeviceIdentifier &&devID, property_template_t &&props = property_template_t(0, "empty"))
		    : Device(std::move(devID), std::move(props))
		{}

		// Property Deserializer. The base Device::deserializeProperties references the DeviceSerializerMethods template specialized by DESERIALIZER_T
		// Note the default property values. If no property_template_t is specified, they will be used. They should be the same as the ones in the constructor above
		// Also note that this function override must only be provided if default property values should be set on instantiation
		template<class DESERIALIZE_T>
		static auto deserializeProperties(DESERIALIZE_T &&data)
		{	return Device::deserializeProperties(std::forward<DESERIALIZE_T>(data), 0, "empty");	}

		const int &number() const
		{	return this->getPropertyByName<"number">();	}

		int &number()
		{	return this->getPropertyByName<"number">();	}

		const std::string &string() const
		{	return this->getPropertyByName<"string">(); }

		std::string &string()
		{	return this->getPropertyByName<"string">();	}

};
\endcode

Finally, Devices are both the input and output of TransceiverFunctions. To this end, Python wrappers are provided for each device type. Devices can be declared as TransceiverFunction inputs using the dedicated decorator:

\code{.py}
@FromEngineDevice(keyword='device_name', id=DeviceIdentifier('device_name', 'engine_name'))
\endcode

After that they can be accessed in TFs as input arguments. More details are provided in this \ref transceiver_function "page". When passed as TF arguments, Devices behave at all effect as read-only objects. Even though it is possible to modify their data or to add new attributes to them inside of a TransceiverFunction, these changes will have no effect outside of the TransceiverFunction.

\section device_serialization Device Serialization

The base classes which handle the de-/serialization of Device data are PropertyTemplate, PropertySerializer and DeviceSerializerMethods.

PropertyTemplate implement heterogeneous data structures which elements can be iterated. That makes them suitable for de-/serialization operations. See this \subpage property_template "page" for further details.

PropertySerializer provides static methods for de-/serializing property templates from and to any serialization data type, with PropertySerializerMethods handling concrete implementations for concrete serialization data types. See this \subpage property_serializer "page" for further details.

Finally, DeviceSerializerMethods class template implements methods to deserialize Devices from and to concrete serialization data types. Since Device class inherits from PropertyTemplate, DeviceSerializerMethods specializations can internally use PropertySerializer to handle the actual data de-/serialization operations. An example can be found in the DeviceSerializerMethods<nlohmann::json> implemenation in file \ref nrp_json_engine_protocol/device_interfaces/json_device_serializer.h.

 */
